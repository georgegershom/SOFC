================================================================================
SOFC SIMULATION - QUICK START GUIDE
================================================================================

This package provides a complete Abaqus/Standard implementation for SOFC 
thermal cycling analysis with damage and delamination modeling.

================================================================================
FILES INCLUDED
================================================================================

1. sofc_simulation.py         - Main Abaqus model generation script
2. sofc_postprocess.py         - Post-processing and damage calculation
3. run_all_simulations.sh      - Automated batch runner for all scenarios
4. visualize_results.py        - Generate plots from results
5. README_SIMULATION.md        - Complete documentation
6. QUICK_START_GUIDE.txt       - This file

================================================================================
PREREQUISITES
================================================================================

- Abaqus/Standard (2020 or later recommended)
- Bash shell (Linux/macOS) or WSL (Windows)
- Python for visualization (matplotlib, numpy)
- Minimum 8 GB RAM, 4+ CPU cores recommended
- ~10 GB free disk space for results

================================================================================
RUNNING THE SIMULATION - THREE OPTIONS
================================================================================

OPTION 1: Automated Batch (Recommended)
----------------------------------------
Run all three heating rate scenarios automatically:

    ./run_all_simulations.sh

This will:
  ✓ Generate models (HR1, HR4, HR10)
  ✓ Run simulations sequentially
  ✓ Post-process all results
  ✓ Generate summary report

Estimated time: 4-8 hours (depends on hardware)


OPTION 2: Interactive CAE
--------------------------
For manual control and visualization during setup:

Step 1: Launch Abaqus CAE
    abaqus cae

Step 2: In CAE Python console, run:
    execfile('sofc_simulation.py')

Step 3: Models will be created (HR1, HR4, HR10)
    - Review geometry, materials, mesh
    - Modify if needed
    
Step 4: Submit job (Job Manager → Submit)

Step 5: After completion, post-process:
    abaqus python sofc_postprocess.py Job_SOFC_HR1.odb


OPTION 3: Command-Line Single Scenario
---------------------------------------
For running one scenario at a time:

Step 1: Generate model
    abaqus cae noGUI=sofc_simulation.py

Step 2: Extract input file (in CAE Python console or script)
    from abaqus import *
    openMdb('SOFC_HR1.cae')
    mdb.Job(name='Job_SOFC_HR1', model='SOFC_HR1', numCpus=4)
    mdb.jobs['Job_SOFC_HR1'].writeInput()

Step 3: Run analysis
    abaqus job=Job_SOFC_HR1 cpus=4 interactive

Step 4: Post-process
    abaqus python sofc_postprocess.py Job_SOFC_HR1.odb

Step 5: Visualize
    python visualize_results.py Job_SOFC_HR1_results.npz

================================================================================
OUTPUT FILES
================================================================================

After running, you will have:

Model Files:
  SOFC_HR*.cae                  - Abaqus CAE models
  Job_SOFC_HR*.inp              - Abaqus input files

Results:
  Job_SOFC_HR*.odb              - Results database (open in Abaqus/Viewer)
  Job_SOFC_HR*_results.npz      - NumPy archive (all field data)
  Job_SOFC_HR*_summary.csv      - Time-series metrics (Excel/plotting)

Visualizations:
  *_thermal_history.png
  *_stress_evolution.png
  *_delamination_risk.png
  *_damage_evolution.png
  *_strain_accumulation.png
  *_field_snapshot.png
  SOFC_comparison_scenarios.png (if multiple runs)

Reports:
  SOFC_simulation_report.txt    - Combined summary

================================================================================
KEY RESULTS TO CHECK
================================================================================

1. Maximum von Mises Stress
   - Should peak during heating/cooling ramps
   - Typical: 100-300 MPa depending on rate
   - Location: Usually at interfaces or in electrolyte

2. Delamination Risk
   - Risk < 1.0 = OK
   - Risk > 1.0 = Delamination likely
   - Check all three interfaces (A-E, E-C, C-I)

3. Crack Depth
   - Measured in electrolyte layer
   - Compare with XRD/DIC experimental data
   - Higher heating rates → deeper cracks

4. Damage Field
   - D = 0: No damage
   - D = 1: Complete damage
   - Threshold D > 0.2 for crack detection

================================================================================
TROUBLESHOOTING
================================================================================

Problem: "abaqus: command not found"
Solution: Load Abaqus module or add to PATH
    module load abaqus
    # OR
    export PATH=/path/to/abaqus/Commands:$PATH

Problem: "Convergence failure"
Solution: 
    - Reduce time increment (initialInc=0.1)
    - Refine mesh at interfaces
    - Check material units (must be SI)

Problem: "Temperature field not found"
Solution: Ensure Step A (heat) completes before Step B (mech)
    - Both steps must be in same job
    - Check ODB file exists

Problem: Post-processing fails
Solution: Must use Abaqus Python (not system Python)
    abaqus python sofc_postprocess.py <odb>
    # NOT: python sofc_postprocess.py <odb>

Problem: Out of memory
Solution:
    - Reduce mesh density (ELEMS_X = 40 instead of 80)
    - Reduce output frequency (fewer frames)
    - Use 64-bit Abaqus with more memory allocation

================================================================================
CUSTOMIZATION
================================================================================

Change Heating Rate:
  Edit HEATING_SCENARIOS dict in sofc_simulation.py
  Example: Add HR2 (2 °C/min)
      'HR2': (2.0, 900.0, 10.0)

Change Target Temperature:
  Modify second value in HEATING_SCENARIOS tuple
  Example: 800 °C instead of 900 °C
      'HR1': (1.0, 800.0, 10.0)

Change Mesh Density:
  Edit in sofc_simulation.py:
      ELEMS_X = 40  # Coarser (faster)
      ELEMS_X = 160 # Finer (slower, more accurate)

Add Cohesive Surfaces (Explicit Delamination):
  See README_SIMULATION.md section "Customization → Add Cohesive Surfaces"

Switch to Coupled Analysis:
  Change element type: CPS4 → CPS4T
  Combine thermal/mechanical steps into one

================================================================================
VALIDATION WORKFLOW
================================================================================

1. Run baseline simulation (HR1)
2. Compare results with experimental data:
   - Crack depth (μm) vs XRD measurements
   - Strain field vs DIC measurements
   - Delamination location vs SEM images
3. Adjust material parameters if needed
4. Run parametric study (HR1, HR4, HR10)
5. Identify optimal heating rate
6. Use ML/PSO for parameter optimization (separate workflow)

================================================================================
PERFORMANCE BENCHMARKS
================================================================================

Typical Runtime (4 cores, 8 GB RAM):

  HR1  (1 °C/min):  2.5 - 3.0 hours
  HR4  (4 °C/min):  1.0 - 1.5 hours
  HR10 (10 °C/min): 0.5 - 0.75 hours

Memory Usage:
  Peak: ~4 GB per scenario
  ODB file: ~500 MB - 1 GB
  NPZ file: ~100 MB - 300 MB

Disk Space (all scenarios):
  Total: ~8-10 GB

Scaling:
  - Linear speedup up to 8 cores
  - Diminishing returns beyond 16 cores
  - GPU not utilized (Abaqus/Standard is CPU-only)

================================================================================
NEXT STEPS AFTER SIMULATION
================================================================================

1. Review Results in Abaqus/Viewer
   - Load ODB: abaqus viewer odb=Job_SOFC_HR1.odb
   - Plot S, Mises (stress hotspots)
   - Animate TEMP (thermal gradients)
   - Path plots at interfaces

2. Analyze NPZ Data with Python
   - Load: data = np.load('Job_SOFC_HR1_results.npz')
   - Extract fields: stress, strain, damage
   - Compute custom metrics
   - Export to other formats (HDF5, CSV)

3. Generate Publication Plots
   - Run: python visualize_results.py --all
   - Customize plot_*.py functions as needed
   - Export high-res images (300 dpi)

4. Parameter Sensitivity Study
   - Vary material properties (E, α, k)
   - Test different mesh densities
   - Explore cohesive parameters

5. Integration with ML/Optimization
   - Use NPZ data as training set
   - Feed to neural network or surrogate model
   - Run PSO for design optimization
   - Loop: simulation → ML → new parameters → simulation

================================================================================
CITATION & LICENSE
================================================================================

If you use this simulation framework, please cite:

  [Your Name], "Sequential Multi-Physics Simulation of SOFC Thermal 
  Cycling with Damage and Delamination Modeling", 2025.

License: MIT (free for academic and commercial use with attribution)

================================================================================
SUPPORT & CONTACT
================================================================================

Documentation:  See README_SIMULATION.md for full details
Issues:         [GitHub repository or email]
Questions:      [your.email@institution.edu]

================================================================================
QUICK REFERENCE COMMANDS
================================================================================

Generate models:
  abaqus cae noGUI=sofc_simulation.py

Run single job:
  abaqus job=Job_SOFC_HR1 cpus=4 interactive

Post-process:
  abaqus python sofc_postprocess.py Job_SOFC_HR1.odb

Visualize:
  python visualize_results.py Job_SOFC_HR1_results.npz

View results:
  abaqus viewer odb=Job_SOFC_HR1.odb

Check job status:
  abaqus job=Job_SOFC_HR1 status

================================================================================
END OF QUICK START GUIDE
================================================================================

For detailed documentation, see README_SIMULATION.md

Good luck with your SOFC simulations!
